/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useEffect } from 'react'; // Added useState and useEffect
import { useGLTF, useAnimations } from '@react-three/drei';

export function Model(props) {
  const group = useRef();
  // Destructure for easier access and to handle potential undefined values safely
  const { nodes, materials, animations } = useGLTF('/cat.glb');
  
  // It's safer to check if nodes['0'] exists before destructuring from it
  const meshNode = nodes && nodes['0'];
  const geometry = meshNode?.geometry;
  const initialMorphTargetInfluences = meshNode?.morphTargetInfluences;
  const morphTargetDictionary = meshNode?.morphTargetDictionary;

  const { actions } = useAnimations(animations, group);

  // State for the morph target influences
  // Initialize with the influences from the loaded GLTF model, or an empty array
  const [influences, setInfluences] = useState(initialMorphTargetInfluences || []);

  // Effect to update local state if the model (nodes) reloads or initial influences change
  useEffect(() => {
    // Ensure meshNode and its properties are defined before setting state
    if (meshNode && initialMorphTargetInfluences) {
      setInfluences(initialMorphTargetInfluences);
    } else if (meshNode && morphTargetDictionary) {
      // If initialMorphTargetInfluences is undefined but dictionary exists,
      // it implies morph targets are present, initialize influences to an array of zeros
      const numMorphTargets = Object.keys(morphTargetDictionary).length;
      setInfluences(new Array(numMorphTargets).fill(0));
    } else {
      setInfluences([]); // Fallback to empty array
    }
  }, [meshNode, initialMorphTargetInfluences, morphTargetDictionary]); // Re-run if these dependencies change

  const handlePointerOver = () => {
    if (morphTargetDictionary && influences) {
      const index = morphTargetDictionary['target_0'];
      if (index !== undefined && influences[index] !== undefined) {
        // Create a new array for React state update (immutability)
        const newInfluences = [...influences];
        newInfluences[index] = 1;
        setInfluences(newInfluences);
      }
    }
  };

  const handlePointerOut = () => {
    if (morphTargetDictionary && influences) {
      const index = morphTargetDictionary['target_0'];
      if (index !== undefined && influences[index] !== undefined) {
        // Create a new array for React state update
        const newInfluences = [...influences];
        newInfluences[index] = 0;
        setInfluences(newInfluences);
      }
    }
  };

  // If the meshNode or its geometry isn't loaded yet, you might want to return null or a loader
  if (!meshNode || !geometry || !materials['Muchkin2.001']) {
    // Or some fallback / loading indicator specific to this component
    return null; 
  }

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <mesh
          name="0"
          castShadow
          receiveShadow
          geometry={geometry} // Use destructured geometry
          material={materials['Muchkin2.001']}
          morphTargetDictionary={morphTargetDictionary} // Pass the dictionary
          morphTargetInfluences={influences} // Pass the state-controlled influences
          userData={{ targetNames: ['target_0'], name: '0' }}
          onPointerOver={handlePointerOver} // Event for mouse hover
          onPointerOut={handlePointerOut}   // Event for mouse leaving
        />
      </group>
    </group>
  );
}

useGLTF.preload('/cat.glb');
