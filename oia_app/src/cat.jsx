/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useEffect } from 'react';
import { useGLTF, useAnimations } from '@react-three/drei';

export function Model(props) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF('/cat.glb');
  
  // --- Logging for model loading ---
  useEffect(() => {
    console.log("useGLTF result:", { nodes, materials, animations });
  }, [nodes, materials, animations]);

  const meshNode = nodes && nodes['0'];
  const geometry = meshNode?.geometry;
  const initialMorphTargetInfluences = meshNode?.morphTargetInfluences;
  const morphTargetDictionary = meshNode?.morphTargetDictionary;

  const { actions } = useAnimations(animations, group);

  const [influences, setInfluences] = useState([]);
  const [targetMorph0Value, setTargetMorph0Value] = useState(0);
  const morphAnimationFrameId = useRef(null);

  const [isHovering, setIsHovering] = useState(false);
  const yRotationAnimationFrameId = useRef(null);

  const yHoverAnimationFrameId = useRef(null);
  const hoverTime = useRef(0);

  useEffect(() => {
    if (meshNode && influences.length === 0) {
      console.log("Initializing morph target influences");
      let initialValues;
      if (initialMorphTargetInfluences) {
        initialValues = [...initialMorphTargetInfluences];
      } else if (morphTargetDictionary) {
        const numMorphTargets = Object.keys(morphTargetDictionary).length;
        initialValues = new Array(numMorphTargets).fill(0);
      } else {
        initialValues = [];
      }
      setInfluences(initialValues);
    } else if (!meshNode && influences.length === 0) {
        console.log("meshNode not yet available for morph init.");
    }
  }, [meshNode, initialMorphTargetInfluences, morphTargetDictionary, influences.length]);

  const handlePointerOver = () => {
    setTargetMorph0Value(1);
    setIsHovering(true);
  };

  const handlePointerOut = () => {
    setTargetMorph0Value(0);
    setIsHovering(false);
  };

  useEffect(() => {
    if (!morphTargetDictionary || !influences || influences.length === 0) {
        // console.log("Morph animation: Waiting for dictionary or influences.");
        return;
    }
    const morphName = 'target_0';
    const index = morphTargetDictionary[morphName];
    if (index === undefined || influences[index] === undefined) {
        // console.log("Morph animation: target_0 index not found or influence not ready.");
        return;
    }

    const animateMorph = () => {
      let currentVal = influences[index];
      const diff = targetMorph0Value - currentVal;
      if (Math.abs(diff) < 0.01) {
        if (currentVal !== targetMorph0Value) {
          const newInfluences = [...influences];
          newInfluences[index] = targetMorph0Value;
          setInfluences(newInfluences);
        }
        if (morphAnimationFrameId.current) cancelAnimationFrame(morphAnimationFrameId.current);
        morphAnimationFrameId.current = null;
        return;
      }
      currentVal += diff * 0.1;
      const newInfluences = [...influences];
      newInfluences[index] = currentVal;
      setInfluences(newInfluences);
      morphAnimationFrameId.current = requestAnimationFrame(animateMorph);
    };

    if (morphAnimationFrameId.current) cancelAnimationFrame(morphAnimationFrameId.current);
    if (influences[index] !== targetMorph0Value) {
      morphAnimationFrameId.current = requestAnimationFrame(animateMorph);
    }
    return () => {
      if (morphAnimationFrameId.current) cancelAnimationFrame(morphAnimationFrameId.current);
    };
  }, [targetMorph0Value, influences, morphTargetDictionary]);

  useEffect(() => {
    if (!group.current) {
        // console.log("Y-Rotation Hover: group.current not ready");
        return;
    }

    const spinSpeed = 0.05; 
    const revertDamping = 0.08; 
    const baseYRotation = (props.rotation && typeof props.rotation[1] === 'number') ? props.rotation[1] : 0;

    const animateYRotation = () => {
      if (!group.current) {
        if (yRotationAnimationFrameId.current) cancelAnimationFrame(yRotationAnimationFrameId.current);
        yRotationAnimationFrameId.current = null;
        return;
      }

      if (isHovering) {
        group.current.rotation.y += spinSpeed;
      } else {
        const currentY = group.current.rotation.y;
        const diff = baseYRotation - currentY;
        if (Math.abs(diff) < 0.005) {
          if (currentY !== baseYRotation) group.current.rotation.y = baseYRotation;
          if (yRotationAnimationFrameId.current) cancelAnimationFrame(yRotationAnimationFrameId.current);
          yRotationAnimationFrameId.current = null;
          return;
        }
        group.current.rotation.y += diff * revertDamping;
      }
      yRotationAnimationFrameId.current = requestAnimationFrame(animateYRotation);
    };

    if (yRotationAnimationFrameId.current) cancelAnimationFrame(yRotationAnimationFrameId.current);
    yRotationAnimationFrameId.current = requestAnimationFrame(animateYRotation);
    return () => {
      if (yRotationAnimationFrameId.current) cancelAnimationFrame(yRotationAnimationFrameId.current);
    };
  }, [isHovering, group, props.rotation]);

  useEffect(() => {
    if (!group.current) {
        console.log("Y-Hover Animation: group.current is NOT YET available.");
        return;
    }
    console.log("Y-Hover Animation: group.current IS available. Initializing animation.");

    const hoverAmplitude = 0.6; // INCREASED AMPLITUDE FOR VISIBILITY
    const hoverSpeed = 0.02;
    const baseYPosition = (props.position && typeof props.position[1] === 'number') ? props.position[1] : 0;
    console.log("Y-Hover Animation: baseYPosition:", baseYPosition, "hoverAmplitude:", hoverAmplitude);


    const animateYHover = () => {
      if (!group.current) {
        if (yHoverAnimationFrameId.current) cancelAnimationFrame(yHoverAnimationFrameId.current);
        yHoverAnimationFrameId.current = null;
        return;
      }
      hoverTime.current += hoverSpeed;
      group.current.position.y = baseYPosition + Math.sin(hoverTime.current) * hoverAmplitude;
      yHoverAnimationFrameId.current = requestAnimationFrame(animateYHover);
    };

    if (yHoverAnimationFrameId.current) cancelAnimationFrame(yHoverAnimationFrameId.current);
    yHoverAnimationFrameId.current = requestAnimationFrame(animateYHover);

    return () => {
      if (yHoverAnimationFrameId.current) cancelAnimationFrame(yHoverAnimationFrameId.current);
    };
  }, [group, props.position]); // This effect runs when group ref or props.position changes

  // --- Logging before conditional return ---
  if (!meshNode || !geometry || !materials['Muchkin2.001']) {
    console.error("Model data missing! Component will render null.", {
        hasMeshNode: !!meshNode,
        hasGeometry: !!geometry,
        hasMaterial: !!(materials && materials['Muchkin2.001'])
    });
    return null; 
  }
  // console.log("Model component WILL render the group.");

  return (
    <group ref={group} {...props} dispose={null}> 
      <group name="Scene">
        <mesh
          name="0"
          castShadow
          receiveShadow
          geometry={geometry}
          material={materials['Muchkin2.001']}
          morphTargetDictionary={morphTargetDictionary}
          morphTargetInfluences={influences}
          userData={{ targetNames: ['target_0'], name: '0' }}
          onPointerOver={handlePointerOver}
          onPointerOut={handlePointerOut}
        />
      </group>
    </group>
  );
}

useGLTF.preload('/cat.glb');
